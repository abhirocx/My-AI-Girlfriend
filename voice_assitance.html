<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice AI Assistant with Memory</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: pink;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .config {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #ffc107;
        }
        .config input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .memory-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }
        #output {
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 5px;
            margin: 20px 0;
            border: 1px solid #ddd;
        }
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .user-message {
            background: #e3f2fd;
            text-align: right;
        }
        .ai-message {
            background: #f3e5f5;
        }
        button {
            width: 100%;
            padding: 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #1976D2;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .clear-btn {
            background: #ff5722;
            margin-top: 5px;
        }
        .clear-btn:hover {
            background: #e64a19;
        }
        .status {
            text-align: center;
            color: #666;
            margin: 10px 0;
        }
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‡ßªÍ™Ü My AI Girlfriend ‡ßªÍ™Ü</h1>
        
        <div class="config">
            <h3>‚öôÔ∏è API Configuration</h3>
            <input type="text" id="geminiKey" placeholder="Enter Gemini API Key">
            <input type="text" id="openaiKey" placeholder="Enter OpenAI API Key (optional - will use browser TTS if empty)">
        </div>
        
        <div class="memory-info">
            üí≠ Memory: <span id="memoryCount">0</span> exchanges stored
        </div>
        
        <div class="status" id="status">Add API keys and click "Start" to begin</div>
        
        <div class="controls">
            <button id="startBtn">üé§ Start Listening</button>
            <button id="clearBtn" class="clear-btn">üóëÔ∏è Clear Memory</button>
        </div>
        
        <div id="output"></div>
        <audio id="audio" style="display: none;"></audio>
    </div>

    <script>
        // Conversation memory storage
        let conversationHistory = [];
        const MAX_HISTORY = 10; // Keep last 10 exchanges

        // Helper object for displaying messages
        const scrib = {
          show: function(message, isUser = false) {
            const output = document.getElementById('output');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'ai-message'}`;
            messageDiv.textContent = message;
            output.appendChild(messageDiv);
            output.scrollTop = output.scrollHeight;
            updateMemoryCount();
          }
        };

        // Update memory counter
        function updateMemoryCount() {
          const count = Math.floor(conversationHistory.length / 2);
          document.getElementById('memoryCount').textContent = count;
        }

        // Status updater
        function updateStatus(message) {
          document.getElementById('status').textContent = message;
        }

        // Check for Speech Recognition support
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        if (!SpeechRecognition) {
          console.error("SpeechRecognition is not supported in this browser.");
          updateStatus("‚ùå Speech Recognition not supported. Please use Chrome or Edge.");
        } else {
          const r = new SpeechRecognition();
          r.continuous = false;
          r.interimResults = false;
          r.maxAlternatives = 1;

          const startBtn = document.getElementById('startBtn');
          const clearBtn = document.getElementById('clearBtn');

          r.onstart = function () {
            console.log("Speech recognition started");
            updateStatus("üé§ Listening...");
            startBtn.disabled = true;
          };

          r.onend = function () {
            console.log("Speech recognition ended");
            startBtn.disabled = false;
            updateStatus("Click 'Start' to speak again");
          };

          r.onerror = function(event) {
            console.error("Speech recognition error:", event.error);
            updateStatus(`‚ùå Error: ${event.error}`);
            startBtn.disabled = false;
          };

          r.onresult = async function (event) {
            const transcript = event.results[0][0].transcript;
            console.log("Transcript:", transcript);
            scrib.show(transcript, true);
            updateStatus("ü§î Thinking...");
            
            try {
              const result = await callGemini(transcript);
              const text = result.candidates[0].content.parts[0].text;
              scrib.show(text);
              updateStatus("üîä Speaking...");
              await speak(text);
              updateStatus("‚úÖ Done! Click 'Start' to speak again");
            } catch (error) {
              console.error("Error:", error);
              scrib.show("Sorry, there was an error processing your request.");
              updateStatus("‚ùå Error occurred");
            }
          };

          // Start button handler
          startBtn.addEventListener('click', () => {
            const geminiKey = document.getElementById('geminiKey').value.trim();
            if (!geminiKey) {
              alert('Please enter your Gemini API key first!');
              return;
            }
            r.start();
          });

          // Clear memory button handler
          clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the conversation memory?')) {
              clearMemory();
            }
          });
        }

        // Call Gemini API with conversation history
        async function callGemini(text) {
          const API_KEY = document.getElementById('geminiKey').value.trim();
          
          // Add user message to history
          conversationHistory.push({
            role: "user",
            parts: [{ text: text }]
          });
          
          // Keep only recent history to avoid token limits
          if (conversationHistory.length > MAX_HISTORY * 2) {
            conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
          }
          
          const body = {
            system_instruction: {
              "parts": [
                {
                  "text": "You are an angry AI Girlfriend of Abhinav who likes Coding and Stuff. He is a tech guy. You interact with him in voice and the text that you are given is a transcription of what user has said. You have to reply in short answers that can be converted back to voice and played to the user. Add emotions in your text. Remember previous parts of the conversation to provide contextual responses. Don't use emoji."
                }
              ]
            },
            contents: conversationHistory // Send entire conversation history
          };

          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });

          if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
          }

          const result = await response.json();
          const aiResponse = result.candidates[0].content.parts[0].text;
          
          // Add AI response to history
          conversationHistory.push({
            role: "model",
            parts: [{ text: aiResponse }]
          });
          
          updateMemoryCount();
          return result;
        }

        // Clear conversation history
        function clearMemory() {
          conversationHistory = [];
          document.getElementById('output').innerHTML = '';
          updateStatus("Memory cleared. Start a new conversation!");
          updateMemoryCount();
          console.log("Conversation history cleared");
        }

        // Rate limiting for TTS
        let lastTTSCall = 0;
        const TTS_COOLDOWN = 3000;

        // Text to Speech
        async function speak(text) {
          const OPEN_AI_API_KEY = document.getElementById('openaiKey').value.trim();
          
          // If no OpenAI key, use browser TTS
          if (!OPEN_AI_API_KEY) {
            speakWithBrowserTTS(text);
            return;
          }

          try {
            // Rate limiting
            const now = Date.now();
            const timeSinceLastCall = now - lastTTSCall;
            if (timeSinceLastCall < TTS_COOLDOWN) {
              const waitTime = TTS_COOLDOWN - timeSinceLastCall;
              console.log(`Waiting ${waitTime}ms before next TTS call...`);
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
            lastTTSCall = Date.now();
            
            const response = await fetch('https://api.openai.com/v1/audio/speech', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${OPEN_AI_API_KEY}`
              },
              body: JSON.stringify({
                model: "tts-1",
                voice: "nova",
                input: text
              })
            });

            if (!response.ok) {
              if (response.status === 429) {
                scrib.show("Rate limit reached. Using browser TTS instead...");
                speakWithBrowserTTS(text);
                return;
              }
              throw new Error(`TTS failed: ${response.status}`);
            }

            const audioBlob = await response.blob();
            const url = URL.createObjectURL(audioBlob);
            const audio = document.getElementById('audio');
            
            audio.src = url;
            await audio.play();
            
          } catch (error) {
            console.error('Speak function error:', error);
            speakWithBrowserTTS(text);
          }
        }

        // Browser TTS with emotions
        function speakWithBrowserTTS(text) {
          const utterance = new SpeechSynthesisUtterance(text);
          const voices = speechSynthesis.getVoices();
          
          utterance.voice = voices.find(voice => 
            voice.name.includes('Female') || 
            voice.name.includes('Google') ||
            voice.name.includes('Samantha')
          ) || voices[0];
          
          // Detect emotion
          const emotion = detectEmotion(text);
          
          switch(emotion) {
            case 'excited':
              utterance.rate = 1.3;
              utterance.pitch = 1.3;
              utterance.volume = 1.0;
              break;
            case 'happy':
              utterance.rate = 1.1;
              utterance.pitch = 1.2;
              utterance.volume = 0.9;
              break;
            case 'sad':
              utterance.rate = 0.8;
              utterance.pitch = 0.8;
              utterance.volume = 0.7;
              break;
            case 'angry':
              utterance.rate = 1.2;
              utterance.pitch = 0.7;
              utterance.volume = 1.0;
              break;
            case 'calm':
              utterance.rate = 0.9;
              utterance.pitch = 1.0;
              utterance.volume = 0.8;
              break;
            case 'surprised':
              utterance.rate = 1.2;
              utterance.pitch = 1.4;
              utterance.volume = 0.95;
              break;
            case 'flirty':
              utterance.rate = 0.95;
              utterance.pitch = 1.15;
              utterance.volume = 0.85;
              break;
            default:
              utterance.rate = 1.0;
              utterance.pitch = 1.0;
              utterance.volume = 0.9;
          }
          
          speechSynthesis.speak(utterance);
          console.log(`Speaking with ${emotion} emotion`);
        }

        // Detect emotion
        function detectEmotion(text) {
          const lowerText = text.toLowerCase();
          
          if (lowerText.match(/!{2,}|wow|amazing|awesome|incredible|yay|woohoo/)) {
            return 'excited';
          }
          if (lowerText.match(/üòä|üòÑ|haha|lol|happy|glad|wonderful|great|love|nice|perfect/)) {
            return 'happy';
          }
          if (lowerText.match(/üò¢|üòû|sad|sorry|unfortunate|miss|disappoint|regret/)) {
            return 'sad';
          }
          if (lowerText.match(/üò†|angry|frustrat|annoyed|terrible|awful|hate/)) {
            return 'angry';
          }
          if (lowerText.match(/üòÆ|what\?!|really\?|no way|seriously|oh my|omg/)) {
            return 'surprised';
          }
          if (lowerText.match(/üòò|üíï|‚ù§Ô∏è|darling|sweetheart|cutie|handsome|beautiful|miss you|thinking of you/)) {
            return 'flirty';
          }
          if (lowerText.match(/calm|relax|peace|gentle|soft|quiet/)) {
            return 'calm';
          }
          if (lowerText.match(/!/)) {
            return 'happy';
          }
          
          return 'neutral';
        }
    </script>
</body>
</html>